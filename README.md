# RSE
**RSE**（*Regular Simplified Expression*）是一种为解决正则表达式使用难题而设计的新工具。正则表达式虽在文本提取等方面有用，但对初学者而言，其符号抽象难记，导致编码效率低且易出错。即使借助 AI，若缺乏对正则表达式规则的基本了解，也难以理解和调整其给出的方案。RSE 使用易记的关键字和范围符，如`begin`（匹配开头）、`end`（匹配结尾）、`rand{}`等，能让非专家用户也可快速写出正确且易理解的代码。通过专门的 RSE 编译器，可将 RSE 转换为标准正则表达式，从而方便用户执行各种文本处理任务，大大简化了正则表达式的创建过程，提高开发者效率并减少出错几率。
## 一、关键字
1. **sigl**：匹配一个除换行符以外的任意字符 = .
2. **begin**：匹配字符串的开始位置 = ^
3. **end**：匹配字符串的结束位置 = $
4. **zemo**：匹配子表达式零次或多次 = *
5. **onmo**：匹配子表达式一次或多次 = +
6. **zoon**：匹配子表达式零次或一次 = ？
7. **exact**：设定精确的匹配次数 ()[] = {n}
8. **rand{}**：匹配给定的任意之一字符 = [abc]
9. **unrand{}**：匹配不在给定的字符集中的字符 = [^abc]
10. **-**：匹配特定范围内的任意一个字符 = -
11. **num**：数字集，{num}等同于{0~9} = \d
12. **lett**：字母集，{lett}等同于{a~z,A~Z} = [a-zA-z]
13. **blett**：大写字母集 = [A-Z]
14. **slett**：小写字母集 = [a-z]
15. **char**：字符集，{char}等同于{num, lett, _} = \w
16. **space**: 空白字符集，包括空格、制表符、换页符 = \s
17. **str()**：表示给定的确切字符集
18. **br**：表示边界 = \b
19. **or**：关系或 = |
20. **group name{}**：捕获子表达式，将其视为一个单位进行处理  = ()
21. **ungroup{}**：分组不捕获匹配内容，将其视为一个单位进行处理 = (?:)
22. **reuse{}**：复用一个之前捕获的组
23. **fpre{}**：正向断言
24. **unfpre{}**：正向否定断言
25. **rpre**：反向断言
26. **unrpre**：反向否定断言
## 二、使用案例
1. 匹配电话号码
```RSE
ungroup{
  ungroup{
    str(+)
    or
    str(00)
  }
  str(86)
}.zeon
str(1)
rand{3-9}
num.exact[9]
```
3. 匹配'<'和'>'间的内容
```RSE
str(<)
group content{
  unrand{str(>)}.zemo
}
str(>)
```
5. 匹配URL
```
begin
ungroup{                        // 创建一个分组，最多出现一次
  str(http)                     // 匹配精确字符串‘http’
  str(s).zeon                   // 匹配精确字符串‘s’，最多出现一次
  str(:\%//)                    // 匹配精确字符串‘://’
}.zeon
rand{lett num}                  // 匹配任意一个字母或数字
rand{- lett num}.exact[0, 62]   // 匹配给定字符组{- 字母 数字}中任意一个字符，设定精确出现次数[0, 62]
ungroup{                        // 创建一个分组，出现一次或多次
  str(.)                        // 匹配精确字符串‘.’
  rand{lett num}                // 匹配任意一个字母或数字
  rand{- lett num}.exact[0, 62] // 匹配给定字符组{- 字母 数字}中任意一个字符，设定精确出现次数[0, 62]
}.onmo
end
```
7. 匹配时间
```
ungroup{
  str(1)
  rand{0-2}
  or
  str(0).zeon
  rand{1-9}
}
str(:)
rand{0-5}
num
str(:)
rand{0-5}
num
```
